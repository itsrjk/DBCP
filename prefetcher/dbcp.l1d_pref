/*
 * Implementation of Dead Block Correlating Prefetcher - Lai, Fide, Falsafi
 * Reuel Johm and Deepraj Pandey
 *
 * 28 April, 2020
 */

#include <map>
#include <utility> // for pair
#include "cache.h"
#include "ooo_cpu.h"

// for the 2-bit saturating counters corresponding to 
// the traces in deadblock table
#define MAX_COUNTER 3

using namespace std;

typedef map<uint64_t, uint64_t>::iterator history_iter;
typedef map<uint64_t, pair<uint8_t, uint64_t>>::iterator deadblock_iter;

uint64_t get_new_signature(uint64_t, uint64_t);
void insert_to_hist(uint64_t, uint64_t);
void printmap();
void printvec(vector<uint64_t>);

// hist_table - block_addr: [PC1, PC2, PC3...]
map<uint64_t, uint64_t> hist_table;
// db_table - signature: [<2bit_saturating_counter, prefetch_addr>, ...]
map<uint64_t, pair<uint8_t, uint64_t>> db_table;

void CACHE::l1d_prefetcher_initialize() 
{
    cout << "CPU " << cpu << " L1D DBCP prefetcher" << endl;
    cout << this->NAME << endl;
}

void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type)
{
    uint64_t tag = addr >> LOG2_BLOCK_SIZE;
    // update history table
    insert_to_hist(tag, ip);

    // this is the current trace for this block
    uint64_t signature = hist_table[tag];

    // Search if the current state of the trace for this block is in the deadblock table
    deadblock_iter db_itr = db_table.find(signature);
    if (db_itr != db_table.end()) {
        // if found, this is a dead block, so increment the 2bit counter and prefetch
        uint8_t trace_count = db_table[signature].first;
        uint8_t pred_confidence = (trace_count >= ((MAX_COUNTER + 1)/2) ? 1 : 0);
        if (pred_confidence) {
            // if we are confident based on the counter, then prefetch
            uint64_t pf_addr = db_table[signature].second;
            prefetch_line(ip, addr, pf_addr, FILL_L1, 0);

            // increment the number of times this trace has resulted in a deadblock
            if (trace_count < MAX_COUNTER) {
                db_table[signature].first += 1;
            }
        }
    }
}

void CACHE::l1d_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
    // this will store the signature corresponding to the tag
    // of the block being evicted
    uint64_t signature;
    uint64_t tag_evict = evicted_addr >> LOG2_BLOCK_SIZE;
    history_iter ht_itr = hist_table.find(tag_evict);
    // found the signature in history table
    if (ht_itr != hist_table.end()) {
        signature = hist_table[tag_evict];

        // Note: the signature is our index into deadblock table

        // Move this block's trace from history table to deadblock table
        deadblock_iter db_itr = db_table.find(signature);
        if (db_itr != db_table.end() && (db_table[signature].first < MAX_COUNTER)) {
            // if found, then just increment the counter
            // each element in the table is a std::pair<> of counter, prefetch_addr
            db_table[signature].first += 1;
        }
        else {
            // add a new entry for this trace in deadblock table
            // initialise 2bit counter to 1, prefetch address = addr
            pair<uint8_t, uint64_t> new_trace (1, addr);
            db_table[signature] = new_trace;
        }

        // Remove this block's entry from history table
        hist_table.erase(tag_evict);
    }
}

void CACHE::l1d_prefetcher_final_stats()
{
    cout << "CPU " << cpu << " L1D DBCP final stats" << endl;
}


//======== Helper Functions ========//
// an implementation of cantor pairing which we use as one of the
// encoding algorithms
// TODO: use bitshifting to do the arithmetic operations
uint64_t cantor_encoding(uint64_t old_sig, uint64_t pc_2)
{
    uint64_t signature = (old_sig + pc_2);
    signature *= (signature+1);
    signature*=0.5;
    signature+=pc_2;
    return signature;
}

// add new_pc to some element in the history table
// if tag doesn't exist, it will place new_pc there
// else, it will add new+pc to the existing trace encoding
void insert_to_hist(uint64_t tag, uint64_t new_pc)
{
    map<uint64_t, uint64_t>::iterator itr = hist_table.find(tag);
    // if we found the element and iterator hasn't reached the end
    if (itr != hist_table.end()) {
        hist_table[tag] = cantor_encoding(hist_table[tag], new_pc);
    }
    else {
        hist_table[tag] = new_pc;
    }
}

void print_hist_table()
{
    for (auto i = hist_table.begin(); i != hist_table.end(); i++) {
        cout << "map: " << i->first << "\t" << i->second;
    }
    cout << endl;
}
